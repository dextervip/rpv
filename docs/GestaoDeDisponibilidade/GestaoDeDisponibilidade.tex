\documentclass{abnt}
%\usepackage[a4paper, inner=1.5cm, outer=2cm, top=3cm, bottom=2cm, bindingoffset=1cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english,brazilian]{babel}
\usepackage{hyperref}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{blindtext}
\hypersetup{%
    pdfborder = {0 0 0}
}
\begin{document}

\autor{Rafael Tavares Amorim \\ Wolmir L. F. Nemitz\\ Juliano R. Macedo}

\titulo{Gerênciamento de Disponibilidade}

\instituicao{Universidade Federal do Pampa \par Engenharia da Software \par Resolução de Problemas V}

\local{Alegrete - RS, Brasil}

\data{19 de Maio de 2012}

\capa

\folhaderosto

\tableofcontents


\chapter{INTRODUÇÃO}

	Este relatório tem por finalidade apresentar a fundamentação teórica e tecnológica utilizada no segundo sprint, bem como o detalhamento de nossa solução, e por fim um link de referência para acesso ao sistema.\ldots

	%\blindenumerate[10]

	\section{Conceitos}
	
	\section{Metodologia Ágil}
	
		Metodologia Ágil é um famoso conjunto de metodologias de desenvolvimento de software, 
		com foco na mitigação dos riscos esta metodologia aposta em pequenos ciclos iterativos de desenvolvimento do software,
		onde ocorre a repetição de cada tarefa comum em um processo de software, ou seja, em cada ciclo realiza-se analise, projeto,
		implementação e testes, referentes aquele módulo, desta forma busca-se à capacidade real de implantar-se um nova versão 
		do software ao final de cada iteração. Ao final de cada clico de iteração a equipe responsável por todo o projeto é reunida 
		e reavalia-se as características, metas e prioridades do projeto como um todo, para que estas sejam aplicadas no próximo ciclo.
		
		Os modelos ágeis são hoje a principal alternativa as metodologias tradicionais de desenvolvimento de software, 
		as quais apresentam diversos problemas estruturais que comprometem a maioria dos projetos, 
		baseados nas necessidades atuais do mercado de software.
	
	\section{Scrum}

		O scrum é uma metodologia ágil, muitos consideram como um framework ágil também, que vem cada dia sendo mais popular
		no desenvolvimento de software.
		O scrum tem o objetivo de agilizar o processo de desenvolvimento de software. O scrum possui basicamente 3
		papéis: Team, Scrum Master e Poduct Owner.
		
		O Product Owner é um papel muito importante no scrum, cabe a ele definir quais funcionalidades devem ou
		não existir no sistema por meio de user stories e também definir a prioridade das user stories. Este papel também
		trata de aprovar ou rejeitar o trabalho realizado e dizer se foi realizado como esperado.
		
		O Scrum Master tem papel de manter a produtividade da equipe facilitando o processo de scrum e resolver impedimentos
		no decorrer dos sprints. Ele ajuda o time a se manter organizado e certificar que as regras do processo estão sendo
		seguidas corretamente. O scrum master não dita o que o time deve fazer mas sim ajuda o time se manter autônomo,
		organizado e com uma boa produtividade. 
		
		O Team tem papel de transformar os itens de backlog em produtos que serão entregues de forma incremental em cada
		sprint. Cabe ao time ter autonomia própria para se organizar e trabalhar de forma de colaborativa ajudando uns aos
		outros sem a necessidade de existência de um ``chefe'' para dizer o que deve ser feito.
		
		O processo de scrum é trabalhado em cima de vários ciclos chamados de sprint, que possuem um tempo fixo, geralmente de
		1 a 4 semanas. Neste ciclo o time irá realizar o sprint backlog
		
		Product Backlog possui uma lista priorizada pelo product owner das funcionalidades desejadas do projeto, e parte
		desta lista irá forma o sprint backlog. É uma coleção de user stories.
		
		Sprint Backlog contêm os itens de backlog que o time concordou completar em um ciclo de sprint, cada item de backlog é
		quebrado em tarefas, atribuídas para equipe e estimado o tempo de realização (por meio de planning poker?).
		
		Planning poker
		
		Tasks
		
		Backlog item ou também conhecido como User Story é um recurso/funcionalidade desejada no sistema que vão compor o
		product backlog. Uma user story usualmente é composta por um ator do sistema e a ação para alcançar determinado
		objetivo. Exemplos: 
			\begin{itemize}
				\item Como um <usuário> Eu posso <realizar ação> para alcançar <determinado objetivo>
				\item Como um cliente, eu posso criar um perfil no sistema
				\item Como um cliente, eu posso escolher um usuário e senha
				\item Como um administrador, eu posso bloquear contas de clientes
			\end{itemize}
				 
		Stories points
		
		No Sprint Planning, a equipe decidirá quais backlog itens irão para o sprint backlog. Depois da priorização das user
		stories pelo product owner, a equipe seleciona o item do topo do product backlog, o qual tem maior prioridade, para a
		discussão e criação das tarefas necessárias para entrega do item. Então as tarefas são atribuídas e estimadas em
		tempo, este processo é repetido até que o time decida que não há possibilidade de realização de mais itens.
		
				
		Burndown é um gráfico que oferece uma forma poderosa de analisar o andamento do projeto. Ele nos oferece
		informações\ldots Pode-se estimar a velocidade de andamento do time
		
		Diariamente há uma reunião conhecida como Daily Meeting, uma reunião com duração aproximada de 15 minutos,
		conduzida pelo scrum master e tem como foco 3 perguntas para todo membro da equipe:
			\begin{itemize}
				\item O que eu fiz ontem?
				\item O que eu estou fazendo hoje?
				\item O que está me impedindo de fazer?
			\end{itemize}
		
		Apesar da reunião ser conduzida pelo scrum master, cada membro deve responder para o time inteiro e não somente para o
		scrum master, todos devem estar de pé na reunião e falar somente quando for perguntado pelo scrum master. No final da
		reunião é discutido por todos soluções caso haja algum impedimento.
		
		Sprint Review tem intuito de demonstrar o que foi realizado no sprint com a presença stakeholders, 
		
		Sprint Retrospective é uma reunião que tem objetivo de discutir se o sprint foi realizado com sucesso ou se é
		necessário melhorias.
		
		O projeto pode ser parado a qualquer momento, as vezes o cliente percebe que as funcionalidade implementadas já foram
		suficientes e atendem a necessidade atual assim não dispersando dinheiro em funcionalidade que talvez nunca seriam
		utilizadas.
	
	\section{Python}
	
		Python é uma conceituada linguagem de programação de alto nível, interpretada, orientada a objetos e de tipagem forte. Idealizada como uma linguagem que valorize o tempo e esforço do programador, Python foca a legibilidade do código, sua indentação, velocidade de desenvolvimento e expressividade. Dentro desta filosofia 
		podemos destacar a forte indentação da linguagem, o que facilita a sua leitura melhorando o visual organizacional da linguagem, e também sua sintaxe simples, limpa e coerente coopera para um rápido aprendizado.
	
	\section{Pip}
	
		Devido à grande quantidade de extensões, bibliotecas e frameworks que utilizam o Python, a comunidade dessa linguagem criou um repositório centralizado de pacotes, o Python Package Index (http://pypi.python.org/pypi).
		Pip é uma ferramenta para instalar e gerenciar pacotes Python, tais como aqueles encontrados no Python Package Index.\cite{PIPSITE}

	\section{Django}
		Django é um framework para desenvolvimento web em Python, cuja proposta
		é encorajar a construção rápida e pragmática de aplicações.\cite{DJANGOSITE}
		O django segue a arquitetura model-view-controller. O modelo das aplicações
		é definido através de classes de modelo que serão mapeadas, mediante o lançamento do projeto,
		para entidades relacionais no banco de dados definido pelos desenvolvedores. A view é
		representada através de funções ou métodos que processam requisições com um sistema
		de templates. O controller é nada mais que a customização das URLs da aplicação,
		que podem ser detectadas através de expressões regulares e redirecionam o
		usuário à view apropriada.\cite{DJANGOWIKIPEDIA}
	
	\section{South}
		
	
	\section{Jenkins}
			
				Jenkins é um servidor de integração contínua de código fonte aberto escrito em Java, e com mais de 300 plugins para
				suportar diferentes tipos de desenvolvimento de software. O Jenkins prover o processo de integração contínua para o
				desenvolvimento de software.
				O processo de integração contínua visa melhorar a qualidade de software e reduzir o tempo de entrega, substituindo a
				prática tradicional de aplicação do controle de qualidade depois do desenvolvimento completo. Os princípios da
				integração contínua são:
				\begin{itemize}
				  \item Manter o código fonte em um repositório de controle de versão
				  \item Automatizar a construção de software
				  \item Fazer a construção de software testar automaticamente o software
				  \item Todo mundo deve comitar para o repositório base todo dia
				  \item Todo commit para repositório base deve ser construído
				  \item A construção deve ser rápida para identificação dos problemas rapidamente
				  \item Testar em um ambiente clone de produção
				  \item Deixar última construção sucedida disponível para os stakeholders e testadores
				  \item Todo mundo pode ver o resultado das últimas construções
				  \item Automatizar o deploy
				\end{itemize}
				
				Sendo importante a parte de testes para que a integração contínua funcione. Existem mecanismos implementados em
				varias linguagens que podem não somente testar o funcionamento total da aplicação mas como verificar a qualidade de
				código fonte escrito baseado em vários fatores como padrão de codificação, detecção de cópias, detecção de erros em
				syntax e problemas de lógica.
				
				A ferramenta Jenkins entra para a execução do processo de integração contínua, irá tratar de obter o código fonte,
				realizar a construção com ajuda do Maven ou Ant, realizar a execução dos testes e fazer o deploy para o servidor de
				teste.

		\section{Klaros Testmanagement}
		
			É uma aplicação web baseada em AJAX escrita em Java para organização e gerenciamento do processo de teste. O sistema
			permite a construção dos casos de teste, gerenciar casos de teste, dividir em suítes de testes, cadastrar os
			ambientes de teste e sistemas que estão rodando o teste, executar testes e coletar os resultados.
			
			Pelos testes realizados no sistema, temos a possibilidade da construção de casos de teste, os casos de teste são
			nomeados, descritos (descrição, pré-condição e pós-condição), priorizados entre os demais, possui estado de
			execução, modo de execução e podem ser divididos em vários passos. Também se pode definir o ambiente de execução
			como Sistema Operacional ou Navegador para aplicações Web. A interface do sistema é bem amigável, não houve
			dificuldades de navegação sobre a aplicação.
			
			\begin{itemize}
			  \item Possui versionamento e histórico sobre os dados.
			  \item Trabalha com casos de teste e seus resultados.
			  \item Gera relatórios em gráficos e tabela sobre os testes. Podendo ser exportado em vários formatos como PDF,
			  HTML, entre outros.
			  \item Possui suporte de integração com as ferramentas de gerenciamento de projeto Redmine, Jira, Trac e Bugzilla.
			  \item É possível através de plugin dos sistemas de integração continua (Hudson/Jenkins) importar os relatórios de
			  execução dos testes automatizados.
			  \item Pode ser instalado em Windows por meio de um executável e Linux por meio de um arquivo jar.
			\end{itemize}
			
			A ferramenta se mostrou muito fácil de instalar como um software que você instala no dia a dia com poucos cliques,
			possui um instalador que facilita muito e instalar todas as dependencias e o servidor em si. Após a instalação, a
			configuração nada mais foi do que informar o usuário e senha para o administrador assim podendo-se inciar as
			atividades de teste na ferramenta. Para integração com gerenciamento de defeitos, na parte administrativa, é
			informado o gerenciamento de defeito, endereço, usuário e senha. 
			
			
	\section{MySQL}

		MySQL é o sistema de gerenciamento de base de dados mais utilizado no mundo.\cite{MYSQLWIKI}
		É o SGBD utilizado no projeto de gerenciamento de disponibilidades por ser livre de custos
		e amplamente documentado.
	

\clearpage
\chapter{SPRINT}
	
	\blindtext
	\section{User Story 1}
	\subsection{Análise}
		A análise do CRUD de disciplinas foi erroneamente baseada em uma expansão da User Story abordada na primeira semana. Com isso, a modelagem e, consequentemente, a implementação da funcionalidade não foram totalmente validadas pelos Product Owners.
		Uma nova modelagem já foi discutida pelo grupo e será submetida a validação pelos PO's no início do próximo sprint.
	
	\section{User Story 2}
	\subsection{Projeto}
	Na modelagem do cadastro de professores e compromissos, as seguintes relações foram propostas:
	Um professor poderia estar vinculado a várias disciplinas e poderia ter vários compromissos, mas apenas uma área de formação.
	Salas também poderiam ter compromissos.
	A sequencia de mensagens está demonstrado através do diagrama em anexo.

\clearpage
%Referências Bibliograficas
\nocite{*}
\bibliographystyle{abnt-num}
%\bibliographystyle{plain}		
\bibliography{bibliografia}		

\end{document}